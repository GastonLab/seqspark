package org.dizhang.seqspark.worker

import org.apache.spark.SparkContext
import org.apache.spark.broadcast.Broadcast
import org.dizhang.seqspark.annot.{Regions, RefGene}
import org.dizhang.seqspark.ds.{Phenotype, StringGenotype, VCF, Variant}
import org.dizhang.seqspark.util.InputOutput._
import org.dizhang.seqspark.util.Constant._
import org.dizhang.seqspark.util.UserConfig._
import org.dizhang.seqspark.worker.Worker.Data

/**
 * import data from VCF file or cache
 */
object Import extends Worker[Unit, Data] {

  implicit val name = new WorkerName("import")

  def apply(none: Unit)(implicit config: RootConfig, sc: SparkContext): Data = {


    logger.info("start importing genotype data")

    val importConfig = config.`import`
    val path = importConfig.path
    val rawPheno = Phenotype(importConfig.sampleInfo)

    val (pheno, samples) = importConfig.samples match {
      case Left(s) => (rawPheno, Left(s))
      case Right(f) => (rawPheno.filter(f), Right(sc.broadcast(rawPheno.indicate(f))))
    }

    importConfig.format match {
      case ImExType.vcf => (makeGenotype(importConfig, sc, samples), pheno)
      case ImExType.cache => (loadGenotype(samples), pheno)
    }
  }

  /**
    * make genotype based on external VCF file
    * e.g. generated by GATK
    */

  def loadGenotype(samples: Either[Samples.Value, Broadcast[Array[Boolean]]])
                  (implicit sc: SparkContext, cnf: RootConfig): VCF = {
    val s1 = VCF.load(cnf.`import`, sc)
    val s2 = cnf.`import`.variants match {
      case Left(Variants.all) => s1
      case Left(Variants.exome) => {
        val coord = cnf.annotation.geneCoord
        val exome = sc.broadcast(Regions.makeExome(coord))
        s1.filter(exome)
      }
      case Left(_) => s1.toDummy
      case Right(b) => s1.filter(b)
    }
    val s3 = samples match {
      case Left(Samples.all) => s2
      case Left(_) => s2.toDummy
      case Right(b) => s1.select(b)
    }
    s3
  }

  def makeGenotype(imCnf: ImExConfig,
                   sc: SparkContext,
                   samples: Either[Samples.Value, Broadcast[Array[Boolean]]])(implicit cnf: RootConfig): VCF = {
    val raw = sc.textFile(imCnf.path)
    val default = if (imCnf.phased) UnPhased.Gt.ref else UnPhased.Gt.ref.bt.toPhased
    val vars = raw filter (l => ! l.startsWith("#") ) map (l => Variant.fromString(l, default))
    //vars.cache()
    //logger.info(s"${vars.count()} variants in total")
    val s1 = vars filter (v =>
      imCnf.filters.contains(v.filter) && v.alleleNum == 2 && imCnf.mutType.contains(v.mutType))

    val s2 = imCnf.variants match {
      case Left(Variants.all) => s1
      case Left(Variants.exome) => {
        val coord = cnf.annotation.geneCoord
        val exome = sc.broadcast(Regions.makeExome(coord))
        s1 filter (v => exome.value.overlap(v.toRegion))
      }
      case Left(_) => s1
      case Right(tree) => s1 filter (v => tree.overlap(v.toRegion))
    }
    //vars.unpersist()
    s2.cache()
    logger.info(s"${s2.count()} variants chosen")
    val s3 = samples match {
      case Left(Samples.all) => s2
      case Left(_) => s2.map(v => Variant.fill[String](v.meta, 0)(default))
      case Right(b) => s2.map(v => v.select(b.value))
    }
    s2.unpersist()
    /** save is very time-consuming and resource-demanding */
    if (imCnf.save)
      try {
        s3.saveAsObjectFile(saveDir)
      } catch {
        case e: Exception => {println("Import: save failed"); System.exit(1)}
      }
    StringGenotype(s3, imCnf)
  }
}
