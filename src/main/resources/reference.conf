seqspark {
  project = seqspark
  localDir = ${PWD}
  dbDir = ref/seqspark_db
  jobs = 128
  pipeline = [qualityControl, association]
  benchmark = false
  debug = false

  input {
    genotype {
      format = vcf
      path = ${seqspark.project}.vcf.bz2
      genomeBuild = hg19
      filter = [] #["FILTER==PASS and INFO.AN!=0  #and (INFO.AC>=10 and INFO.AC<=3800)"]
      samples = all
      variants = all
    }
    phenotype {
      path = ${seqspark.project}.ped
      batch = none
      samples = all
    }
  }


  qualityControl {
    genotypes = [] #["DP >= 8 and DP < 250 and GQ >= 20"]
    variants  = [ #"CADD.score > 3",
      "alleleNum == 2 and missingRate < 0.1",
      "batchMissingRate < 0.1 and batchSpecific < 2 and hwePvalue >= 1e-6"]
    summaries = [ gdgq, pca, titv, sexCheck ]
    save {
      format = vcf
    }
    gdgq {
      fraction = 0.05
    }
  }

  annotation {

    variants {
      dbs = []#[dbNSFP, CADD, ExAC]
      addInfo {
        #dbSNP = "dbSNP"
        #ExAC_AF = "ExAC.AC/ExAC.AN"
        #weight1 = "dbNSFP.score"
        #CADD_Score = "CADD.score"
      }
    }

    genes {
      db = RefSeq
      addInfo {
        gene = "RefSeq.geneName"
        isFunctional = ["splicing", "nonsysnonymous", "misense", "frameshift"]
      }
    }

  }

  association {
    trait {
      list = [] #[control]
      control {
        binary = true
        covariates = ["age", "sex"]
        pc = 2
      }
    }
    #methods = ["single", "cmc", "brv", "VT", "rv-TDT", "SKAT"]
    method {
      list = [] #["snv", "cmc", "brv", "vt"]
      resampling = false
      test = score #could be score, lhr, wald
      misc = {
        groupBy = ["gene"]
        variants = ["isFunctional"]
      }
      filters = [
        "splicing"
        "frameshift insertion"
        "frameshift deletion"
        "frameshift block substitution"
        "stopgain"
        "stoploss"
        "nonsynonymous SNV"
        # it's optional for the nonframeshift variantions
        #        "nonframeshift insertion"
        #        "nonframeshift deletion"
        #        "nonframeshift block substitution"
      ]
      skato {
        type = skato
        weight = skat
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          method = "optimal.adj"
          rCorr = []
          kernel = "linear.weighted"
          weightBeta = [1, 25]
          smallSampleAdjustment = true
        }
      }
      skat {
        type = skat
        weight = skat
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          method = "liu.mod"
          rCorr = []
          kernel = "linear.weighted"
          weightBeta = [1, 25]
          smallSampleAdjustment = true
        }
      }
      rmw {
        type = rmw
        weight = none
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          groupBy = []
          variants = []
        }
      }
      snv {
        type = snv
        weight = none
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          groupBy = []
          variants = []
        }
      }
      cmc {
        type = cmc
        weight = none
        maf {
          source = pooled  #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.01
          fixed = true
        }
        misc = ${seqspark.association.method.misc}
      }
      cadd {
        type = brv
        weight = none
        maf {
          source = pooled
          cutoff = 0.01
          fixed = true
        }
        misc {
          groupBy = [slidingWindow, 4000, 0]
          variants = ["CADD.score >= 3"]
        }
      }
      brv {
        type = brv
        weight = equal #could be wss (),
        maf {
          source = pooled #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.01
          fixed = true
        }
        misc = ${seqspark.association.method.misc}
      }
      wss {
        type = brv
        weight = wss
        maf {
          source = pooled
          cutoff = 0.01
          fixed = true
        }
        misc = ${seqspark.association.method.misc}
      }
      vt {
        type = brv
        weight = wss
        maf {
          source = pooled #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.05
          fixed = false
        }
        misc = ${seqspark.association.method.misc}
      }
    }
  }
}

meta {
  project = seqspark
  seqsparkHome = ${HOME}/seqspark
  localDir = ${PWD}
  hdfsDir = ${seqspark.project}

  studies = [ study1, study2, study3 ]

  trait {
    list = [control]
    control {
      conditional = []
    }
  }
}