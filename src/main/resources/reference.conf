seqspark {
  project = seqspark
  localDir = ${PWD}
  dbDir = ref/seqspark_db
  pipeline = [qualityControl, association]

  input {
    genotype {
      format = vcf
      path = ${seqspark.project}.vcf.bz2
      genomeBuild = hg19
      filters = [PASS]
      samples = all
      variants = all
    }
    phenotype {
      path = ${seqspark.project}.ped
      batch = none
      samples = all
    }
  }

  qualityControl {
    genotypes = ["DP >= 8 and DP < 250 and GQ >= 20"]
    variants  = ["CADD.score > 3",
      "alleleNum == 2 and missingRate < 0.1",
      "batchMissingRate < 0.1 and batchSpecific < 2 and hwePvalue >= 1e-6"]
  }

  annotation {

    variants {
      dbs = [dbNSFP, CADD, ExAC]
      addInfo {
        dbSNP = "dbSNP"
        ExAC_AF = "ExAC.AC/ExAC.AN"
        weight1 = "dbNSFP.score"
        CADD_Score = "CADD.score"
      }
    }

    genes {
      db = RefSeq
      addInfo {
        gene = "RefSeq.geneName"
        isFunctional = ["splicing", "nonsysnonymous", "misense", "frameshift"]
      }
    }

    RefSeq {
      build = hg19
      coord = ${dbDir}/${seqspark.annotation.RefSeq.build}_refFlat_table
      seq = ${dbDir}/${seqspark.annotation.RefSeq.build}_refGene_mRNA
    }

    dbNSFP {
      format = plain
      header = inline
      delimiter = "\t"
      path = ${dbDir}/dbNSFP.bz2
    }

    CADD {
      format = plain
      header = ["chr", "pos", "ref", "alt", "rawScore", "phred"]
      delimiter = "\t"
      path = ${dbDir}/cadd.bz2
    }

    dbSNP {
      format = vcf
      path = ${dbDir}/dbSNP.vcf.bz2
    }

    ExAC {
      format = vcf
      path = ${dbDir}/ExAC.r0.3.sites.vep.vcf.bz2
    }

  }

  association {
    trait {
      list = [control]
      control {
        binary = true
        covariates = ["age", "sex"]
        pc = 2
      }
    }
    #methods = ["single", "cmc", "brv", "VT", "rv-TDT", "SKAT"]
    method {
      list = ["single", "cmc", "brv", "vt"]
      resampling = false
      test = score #could be score, lhr, wald
      misc = {
        groupBy = ["gene"]
        variants = ["isFunctional"]
      }
      filters = [
        "splicing"
        "frameshift insertion"
        "frameshift deletion"
        "frameshift block substitution"
        "stopgain"
        "stoploss"
        "nonsynonymous SNV"
        # it's optional for the nonframeshift variantions
        #        "nonframeshift insertion"
        #        "nonframeshift deletion"
        #        "nonframeshift block substitution"
      ]
      skat {
        type = skat
        weight = skat
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          method = "optimal.adj"
          rCorr = []
          kernel = "linear.weighted"
          weightBeta = [1, 25]
          smallSampleAdjustment = true
        }
      }
      rmw {
        type = rmw
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          groupBy = []
          variants = []
        }
      }
      snv {
        type = snv
        maf {
          source = pooled
          cutoff = 0.01
        }
        misc {
          groupBy = []
          variants = []
        }
      }
      cmc {
        type = cmc
        maf {
          source = pooled  #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.01
          fixed = true
        }
      }
      cadd {
        type = brv
        weight = none
        maf {
          source = pooled
          cutoff = 0.01
          fixed = true
        }
        misc {
          groupBy = [slidingWindow, 4000, 0]
          variants = ["CADD.score >= 3"]
        }
      }
      brv {
        type = brv
        weight = equal #could be wss (),
        maf {
          source = pooled #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.01
          fixed = true
        }
      }
      wss {
        type = brv
        weight = wss
        maf {
          source = pooled
          cutoff = 0.01
          fixed = true
        }
      }
      vt {
        type = brv
        weight = 1
        maf {
          source = pooled #could be 'controls', 'annotation' if it is annotation. seqspark will read seqspark_ANNO_AF
          cutoff = 0.05
          fixed = false
        }
      }
    }
  }
}

meta {
  project = seqspark
  seqsparkHome = ${HOME}/seqspark
  localDir = ${PWD}
  hdfsDir = ${seqspark.project}

  studies = [ study1, study2, study3 ]

  trait {
    list = [control]
    control {
      conditional = []
    }
  }
}